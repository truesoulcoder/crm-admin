'use client'

import { RealtimePostgresChangesPayload } from '@supabase/supabase-js';
import { PlayCircle, AlertCircle, CheckCircle, Info, List, XCircle, RefreshCw } from 'lucide-react';
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Button, Card, Alert, Select } from 'react-daisyui';

import { supabase } from '@/lib/supabase/client';
import { Database } from '@/types/supabase';

// Define types based on Supabase schema
type Campaign = Database['public']['Tables']['campaigns']['Row'];
type EmailEvent = Database['public']['Tables']['email_events']['Row'];

// Based on your MEMORY for eli5_email_log
// Ensure this type is correctly generated by `npx supabase gen types typescript ...`
type Eli5EmailLogEntry = Database['public']['Tables']['eli5_email_log']['Row'];

interface CampaignRunStats {
  attempted: number;
  sent: number;
  failed: number;
  skipped: number;
}

interface LogEntry {
  id: string;
  timestamp: string;
  message: string;
  type: 'info' | 'error' | 'success' | 'warning' | 'campaign' | 'email';
}

interface CampaignWithStatus extends Campaign {
  current_status?: string; 
  settings?: Record<string, any>;
}

// Helper function for formatting status (if not already defined elsewhere)
const formatCampaignStatus = (status: string | null | undefined): string => {
  if (!status) return 'Unknown';
  return status.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};

// Helper function for status color (if not already defined elsewhere)
const getStatusColor = (status: string | null | undefined): string => {
  if (!status) return 'text-gray-500';
  switch (status) {
    case 'running':
    case 'ACTIVE':
      return 'text-success';
    case 'paused':
    case 'PENDING': // Assuming PENDING is a general 'waiting' state
      return 'text-warning';
    case 'error':
    case 'FAILED_TO_SEND':
      return 'text-error';
    case 'completed':
      return 'text-info';
    case 'preflight_pending':
    case 'awaiting_confirmation':
      return 'text-accent'; 
    case 'idle':
    default:
      return 'text-gray-500';
  }
};

const DashboardView: React.FC = () => {
  const [campaigns, setCampaigns] = useState<CampaignWithStatus[]>([]);
  const [selectedCampaignId, setSelectedCampaignId] = useState<string | null>(null);
  const [campaignStatus, setCampaignStatus] = useState<string>('idle');
  const [consoleLogs, setConsoleLogs] = useState<LogEntry[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [eli5ActivityLog, setEli5ActivityLog] = useState<Eli5EmailLogEntry[]>([]);
  const [campaignRunStats, setCampaignRunStats] = useState<CampaignRunStats>({
    attempted: 0,
    sent: 0,
    failed: 0,
    skipped: 0,
  });
  const [isLoadingEli5Data, setIsLoadingEli5Data] = useState<boolean>(false);
  const consoleEndRef = useRef<null | HTMLDivElement>(null);

  const addLog = useCallback((message: string, type: LogEntry['type'] = 'info') => {
    setConsoleLogs(prevLogs => [
      ...prevLogs,
      { id: Date.now().toString() + Math.random().toString(), timestamp: new Date().toISOString(), message, type },
    ]);
  }, []);

  useEffect(() => {
    consoleEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [consoleLogs]);

  const fetchCampaigns = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    addLog('Fetching campaigns...', 'info');
    try {
      const { data, error: campaignsError } = await supabase
        .from('campaigns')
        .select('*')
        .order('name', { ascending: true });

      if (campaignsError) throw campaignsError;
      
      const campaignsWithStatus: CampaignWithStatus[] = data.map((c: Campaign) => ({...c, current_status: c.status || 'idle'}));
      setCampaigns(campaignsWithStatus);
      addLog(`Fetched ${campaignsWithStatus.length} campaigns.`, 'success');
      // Do not automatically select the first campaign here, let user choose or restore from state if needed.
    } catch (err: any) {
      setError(`Error fetching campaigns: ${err.message}`);
      addLog(`Error fetching campaigns: ${err.message}`, 'error');
    } finally {
      setIsLoading(false);
    }
  }, [addLog]);

  useEffect(() => {
    void fetchCampaigns();
  }, [fetchCampaigns]);

  const fetchInitialEli5LogData = useCallback(async (campaignId: string) => {
    if (!campaignId) {
      setEli5ActivityLog([]);
      setCampaignRunStats({ attempted: 0, sent: 0, failed: 0, skipped: 0 });
      return;
    }
    setIsLoadingEli5Data(true);
    addLog(`Fetching ELI5 email log data for campaign ${campaignId}...`, 'info');

    try {
      // Fetch aggregated stats
      const { data: statsData, error: statsError } = await supabase
        .from('eli5_email_log')
        .select('email_status')
        .eq('campaign_id', campaignId);

      if (statsError) throw statsError;

      const newStats: CampaignRunStats = { attempted: 0, sent: 0, failed: 0, skipped: 0 };
      if (statsData) {
        statsData.forEach(log => {
          newStats.attempted += 1;
          if (log.email_status === 'SENT') newStats.sent += 1;
          else if (log.email_status === 'FAILED_TO_SEND') newStats.failed += 1;
          else if (log.email_status === 'SKIPPED') newStats.skipped += 1;
          // Add other statuses if needed, e.g., 'PENDING_SEND' could be part of 'attempted'
        });
      }
      setCampaignRunStats(newStats);
      addLog(`Initial ELI5 stats for campaign ${campaignId}: Attempted: ${newStats.attempted}, Sent: ${newStats.sent}, Failed: ${newStats.failed}, Skipped: ${newStats.skipped}`, 'success');

      // Fetch recent log entries
      const { data: recentLogsData, error: recentLogsError } = await supabase
        .from('eli5_email_log')
        .select('*')
        .eq('campaign_id', campaignId)
        .order('processed_at', { ascending: false })
        .limit(50); // Get the last 50 entries

      if (recentLogsError) throw recentLogsError;
      if (recentLogsData) {
        setEli5ActivityLog(recentLogsData as Eli5EmailLogEntry[]); // Assuming direct cast is safe due to select('*')
        addLog(`Fetched ${recentLogsData.length} recent ELI5 email log entries.`, 'success');
      }

    } catch (err: any) {
      const errorMessage = err.message || 'Unknown error fetching ELI5 log data';
      setError(`Error fetching ELI5 log data: ${errorMessage}`);
      addLog(`Error fetching ELI5 log data: ${errorMessage}`, 'error');
    } finally {
      setIsLoadingEli5Data(false);
    }
  }, [addLog]); // Supabase client and setters are stable

  // Update local campaign status and fetch ELI5 data if selected campaign changes
  useEffect(() => {
    if (selectedCampaignId) {
      const selected = campaigns.find(c => c.id === selectedCampaignId);
      if (selected) {
        setCampaignStatus(selected.current_status || 'idle');
        addLog(`Campaign "${selected.name}" selected. Status: ${selected.current_status || 'idle'}.`, 'info');
      }
      fetchInitialEli5LogData(selectedCampaignId);
    } else {
      setCampaignStatus('idle');
      setEli5ActivityLog([]);
      setCampaignRunStats({ attempted: 0, sent: 0, failed: 0, skipped: 0 });
    }
  }, [selectedCampaignId, campaigns, fetchInitialEli5LogData, addLog]);

  // Supabase Real-time Subscriptions
  useEffect(() => {
    // Channel for general campaign updates
    const campaignUpdatesChannelName = 'dashboard-campaigns-channel';
    const campaignsSubscription = supabase
      .channel(campaignUpdatesChannelName)
      .on(
        'postgres_changes',
        { event: 'UPDATE', schema: 'public', table: 'campaigns' },
        (payload) => {
          addLog(`Campaign update received: ${JSON.stringify(payload.new)}`, 'debug');
          const updatedCampaign = payload.new as Campaign;
          setCampaigns((prevCampaigns) =>
            prevCampaigns.map((c) =>
              c.id === updatedCampaign.id ? { ...c, ...updatedCampaign, current_status: updatedCampaign.status || c.current_status } : c
            )
          );
          if (updatedCampaign.id === selectedCampaignId) {
            setCampaignStatus(updatedCampaign.status || 'idle');
            addLog(`Status for selected campaign "${updatedCampaign.name}" updated to: ${updatedCampaign.status || 'idle'}`, 'info');
          }
        }
      )
      .subscribe((status, err) => {
        if (status === 'SUBSCRIBED') {
          addLog('Subscribed to campaign updates.', 'info');
        } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
          addLog(`Campaign subscription error: ${err?.message || 'Unknown error'}`, 'error');
          setError(`Campaign subscription error: ${err?.message || 'Unknown error'}`);
        }
      });

    // Channel for ELI5 email log inserts (specific to selected campaign)
    let eli5LogSubscription: ReturnType<typeof supabase.channel> | null = null;
    if (selectedCampaignId) {
      const eli5LogChannelName = `dashboard-eli5-log-channel-${selectedCampaignId}`;
      eli5LogSubscription = supabase
        .channel(eli5LogChannelName)
        .on(
          'postgres_changes',
          { event: 'INSERT', schema: 'public', table: 'eli5_email_log', filter: `campaign_id=eq.${selectedCampaignId}` },
          (payload) => {
            addLog(`New ELI5 email log entry: ${JSON.stringify(payload.new)}`, 'debug');
            const newLogEntry = payload.new as Eli5EmailLogEntry;
            setEli5ActivityLog((prevLogs) => [newLogEntry, ...prevLogs.slice(0, 99)]); // Keep max 100 logs
            setCampaignRunStats((prevStats) => {
              const newStats = { ...prevStats, attempted: prevStats.attempted + 1 };
              if (newLogEntry.email_status === 'SENT') newStats.sent += 1;
              else if (newLogEntry.email_status === 'FAILED_TO_SEND') newStats.failed += 1;
              else if (newLogEntry.email_status === 'SKIPPED') newStats.skipped += 1;
              return newStats;
            });
          }
        )
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') {
            addLog(`Subscribed to ELI5 email logs for campaign ${selectedCampaignId}.`, 'info');
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
            addLog(`ELI5 log subscription error for campaign ${selectedCampaignId}: ${err?.message || 'Unknown error'}`, 'error');
            setError(`ELI5 log subscription error: ${err?.message || 'Unknown error'}`);
          }
        });
    }

    return () => {
      addLog('Cleaning up subscriptions...', 'info');
      if (campaignsSubscription) void supabase.removeChannel(campaignsSubscription);
      if (eli5LogSubscription) void supabase.removeChannel(eli5LogSubscription);
    };
  }, [selectedCampaignId, addLog]); // Supabase client and setters are stable

  // TODO: Re-implement preflight/start/stop handlers
  const handleSelectCampaign = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newCampaignId = event.target.value;
    setSelectedCampaignId(newCampaignId);
    // The useEffect above will handle status update and data fetching
  };
  const handleInitiatePreflight = () => { addLog('handleInitiatePreflight called - placeholder', 'info'); };
  const handleConfirmAndStartCampaign = () => { addLog('handleConfirmAndStartCampaign called - placeholder', 'info'); };
  const handleStopCampaign = () => { addLog('handleStopCampaign called - placeholder', 'info'); };
  const handleCancelPreflightOrCampaign = () => { addLog('handleCancelPreflightOrCampaign called - placeholder', 'info'); };

  // JSX for displaying stats and logs (defined before main return)
  const campaignRunStatsDisplay = selectedCampaignId && (
    <Card className="mb-4">
      <Card.Body>
        <Card.Title tag="h2">Campaign Run Activity (ELI5 Log)</Card.Title>
        {isLoadingEli5Data && <p>Loading campaign activity...</p>}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
          <div>
            <div className="stat-title">Attempted</div>
            <div className="stat-value text-info">{campaignRunStats.attempted}</div>
          </div>
          <div>
            <div className="stat-title">Sent</div>
            <div className="stat-value text-success">{campaignRunStats.sent}</div>
          </div>
          <div>
            <div className="stat-title">Failed</div>
            <div className="stat-value text-error">{campaignRunStats.failed}</div>
          </div>
          <div>
            <div className="stat-title">Skipped</div>
            <div className="stat-value text-warning">{campaignRunStats.skipped}</div>
          </div>
        </div>
      </Card.Body>
    </Card>
  );

  const eli5ActivityLogDisplay = selectedCampaignId && (
    <Card className="mt-4">
      <Card.Body>
        <Card.Title tag="h3">ELI5 Real-time Email Log</Card.Title>
        <div className="bg-gray-800 text-white p-4 rounded-md h-64 overflow-y-auto text-xs font-mono">
          {eli5ActivityLog.length === 0 && !isLoadingEli5Data && <p>No email activity recorded for this campaign yet.</p>}
          {isLoadingEli5Data && <p>Loading email activity...</p>}
          {eli5ActivityLog.map((log) => (
            <div key={log.id} className={`mb-1 ${log.email_status === 'FAILED_TO_SEND' ? 'text-red-400' : log.email_status === 'SENT' ? 'text-green-400' : 'text-gray-400'}`}>
              [{new Date(log.processed_at).toLocaleTimeString()}] Campaign: {typeof log.campaign_id === 'string' ? log.campaign_id.substring(0,8) : 'N/A'} Lead: {log.original_lead_id} To: {log.contact_email} - Status: {log.email_status}
              {log.email_status === 'FAILED_TO_SEND' && log.email_error_message && (
                <span className="block pl-4 text-red-500">Error: {log.email_error_message}</span>
              )}
            </div>
          ))}
          {/* Consider a separate ref for this log if consoleEndRef is for the other log */}
        </div>
      </Card.Body>
    </Card>
  );
  // End of eli5ActivityLogDisplay

  return (
    <div className="p-4 space-y-4 max-w-7xl mx-auto">
      <h1 className="text-3xl font-bold mb-6 flex items-center"><List className="mr-3 h-8 w-8" />Campaign Dashboard</h1>

      {error && (
        <Alert status="error" className="alert-error mb-4">
          <AlertCircle className="w-6 h-6 mr-2" />
          <span>{error}</span>
        </Alert>
      )}

      {/* Console Section - General Activity */}
      <Card className="card bordered shadow-lg bg-base-100 mb-6">
        <Card.Body className="p-4">
          <Card.Title tag="h2" className="text-xl mb-3">System & Campaign Activity Console</Card.Title>
          <div className="bg-gray-800 text-white p-3 rounded-md h-48 overflow-y-auto text-xs font-mono" id="console-output">
            {consoleLogs.map(log => (
              <div key={log.id} className={`flex items-start ${log.type === 'error' ? 'text-red-400' : log.type === 'success' ? 'text-green-400' : log.type === 'warning' ? 'text-yellow-400' : 'text-gray-300'}`}>
                <span className="mr-2">[{new Date(log.timestamp).toLocaleTimeString()}]</span>
                <span className="flex-1">{log.message}</span>
              </div>
            ))}
            <div ref={consoleEndRef} />
          </div>
        </Card.Body>
      </Card>

      {/* ELI5 Specific Email Log Display */}
      {selectedCampaignId && eli5ActivityLogDisplay}

      {/* Campaign Selection and Controls Area */}
      <Card className="card bordered shadow-lg bg-base-100 mb-6">
        <Card.Body className="p-4">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-start">
            {/* Column 1: Campaign Selection & Status */}
            <div className="md:col-span-1 space-y-3">
              <h3 className="text-lg font-semibold">Select Campaign:</h3>
              <Select 
                value={selectedCampaignId || ''} 
                onChange={handleSelectCampaign} 
                className="select select-bordered w-full"
                disabled={isLoading || campaignStatus === ('preflight_pending' as CampaignStatus) || campaignStatus === ('running' as CampaignStatus) || campaignStatus === ('awaiting_confirmation' as CampaignStatus)}
              >
                <Select.Option value="" disabled>Choose a campaign</Select.Option>
                {campaigns.map(campaign => (
                  <Select.Option key={campaign.id} value={campaign.id}>{campaign.name}</Select.Option>
                ))}
              </Select>
              {selectedCampaignId && (
                <div className="mt-2 p-3 bg-base-200 rounded-md">
                  <p className="font-semibold text-sm">Status: 
                    <span className={`ml-1 font-bold ${ getStatusColor(campaignStatus)}`}>{formatCampaignStatus(campaignStatus)}</span>
                  </p>
                  {/* Add more campaign details if needed */}
                </div>
              )}
            </div>

            {/* Column 2 & 3: Controls & Actions */}
            {selectedCampaignId && (
              <div className="md:col-span-2 space-y-3">
                <h3 className="text-lg font-semibold">Campaign Actions:</h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
                  {campaignStatus === ('idle' as CampaignStatus) || campaignStatus === ('paused' as CampaignStatus) || campaignStatus === ('completed' as CampaignStatus) || campaignStatus === ('error' as CampaignStatus) ? (
                    <Button 
                      color="primary" 
                      startIcon={<PlayCircle />} 
                      onClick={handleInitiatePreflight}
                      loading={isLoading || campaignStatus === ('preflight_pending' as CampaignStatus)}
                      disabled={isLoading || !selectedCampaignId || campaignStatus === ('preflight_pending' as CampaignStatus) || campaignStatus === ('awaiting_confirmation' as CampaignStatus)}
                    >
                      Start / Resume Campaign
                    </Button>
                  ) : campaignStatus === ('awaiting_confirmation' as CampaignStatus) ? (
                    <Button 
                      color="success" 
                      startIcon={<CheckCircle />} 
                      onClick={handleConfirmAndStartCampaign}
                      loading={isLoading}
                      disabled={isLoading || !selectedCampaignId}
                    >
                      Confirm & Start Sending
                    </Button>
                  ) : campaignStatus === ('running' as CampaignStatus) || campaignStatus === ('preflight_pending' as CampaignStatus) ? (
                    <Button 
                      color="warning" 
                      startIcon={<XCircle />} 
                      onClick={handleStopCampaign}
                      loading={isLoading}
                      disabled={isLoading || !selectedCampaignId}
                    >
                      Stop Campaign
                    </Button>
                  ) : null}
                  
                  {(campaignStatus === ('awaiting_confirmation' as CampaignStatus) || campaignStatus === ('preflight_pending' as CampaignStatus)) && (
                     <Button 
                        variant="outline" 
                        color="ghost" 
                        startIcon={<XCircle />} 
                        onClick={handleCancelPreflightOrCampaign}
                        disabled={isLoading}
                      >
                        Cancel Operation
                      </Button>
                  )}
                  <Button 
                    variant="outline" 
                    color="ghost" 
                    startIcon={<RefreshCw />} 
                    onClick={() => void fetchCampaigns()} // Re-fetch all campaigns
                    disabled={isLoading}
                  >
                    Refresh Campaigns List
                  </Button>
                </div>
              </div>
            )}
          </div>
        </Card.Body>
      </Card>

      {/* Campaign Run Statistics from ELI5 Log */}
      {selectedCampaignId && campaignRunStatsDisplay}
    </div>
  );
};

export default DashboardView;

// ...
